{"ast":null,"code":"export class AudioContextManager {\n  constructor() {\n    this.audioContext = null;\n    this.analyserNode = null;\n    this.sourceNode = null;\n    this.mediaStream = null;\n    this.dataArray = null;\n  }\n  async startMonitoring() {\n    try {\n      if (!this.audioContext) {\n        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      }\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        }\n      });\n      this.mediaStream = stream;\n      this.sourceNode = this.audioContext.createMediaStreamSource(stream);\n      this.analyserNode = this.audioContext.createAnalyser();\n      this.analyserNode.fftSize = 2048;\n      this.analyserNode.smoothingTimeConstant = 0.8;\n      this.analyserNode.minDecibels = -90;\n      this.analyserNode.maxDecibels = -10;\n      this.sourceNode.connect(this.analyserNode);\n      this.dataArray = new Float32Array(this.analyserNode.frequencyBinCount);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error('Failed to start audio monitoring: ' + errorMessage);\n    }\n  }\n  getVolume() {\n    if (!this.analyserNode || !this.dataArray) {\n      return 0;\n    }\n    this.analyserNode.getFloatTimeDomainData(this.dataArray);\n    let sum = 0;\n    for (let i = 0; i < this.dataArray.length; i++) {\n      sum += this.dataArray[i] * this.dataArray[i];\n    }\n    const rms = Math.sqrt(sum / this.dataArray.length);\n    return Math.min(100, Math.max(0, rms * 100));\n  }\n  stopMonitoring() {\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n    }\n    if (this.sourceNode) {\n      this.sourceNode.disconnect();\n    }\n    if (this.audioContext && this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n    }\n    this.audioContext = null;\n    this.analyserNode = null;\n    this.sourceNode = null;\n    this.mediaStream = null;\n    this.dataArray = null;\n  }\n  resume() {\n    var _this$audioContext;\n    if (((_this$audioContext = this.audioContext) === null || _this$audioContext === void 0 ? void 0 : _this$audioContext.state) === 'suspended') {\n      this.audioContext.resume();\n    }\n  }\n  suspend() {\n    var _this$audioContext2;\n    if (((_this$audioContext2 = this.audioContext) === null || _this$audioContext2 === void 0 ? void 0 : _this$audioContext2.state) === 'running') {\n      this.audioContext.suspend();\n    }\n  }\n}\nexport const audioContextManager = new AudioContextManager();","map":{"version":3,"names":["AudioContextManager","constructor","audioContext","analyserNode","sourceNode","mediaStream","dataArray","startMonitoring","window","AudioContext","webkitAudioContext","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","createMediaStreamSource","createAnalyser","fftSize","smoothingTimeConstant","minDecibels","maxDecibels","connect","Float32Array","frequencyBinCount","error","errorMessage","Error","message","getVolume","getFloatTimeDomainData","sum","i","length","rms","Math","sqrt","min","max","stopMonitoring","getTracks","forEach","track","stop","disconnect","state","close","resume","_this$audioContext","suspend","_this$audioContext2","audioContextManager"],"sources":["D:/projects/volume-monitor/src/utils/audioContext.ts"],"sourcesContent":["export class AudioContextManager {\r\n  private audioContext: AudioContext | null = null;\r\n  private analyserNode: AnalyserNode | null = null;\r\n  private sourceNode: MediaStreamAudioSourceNode | null = null;\r\n  private mediaStream: MediaStream | null = null;\r\n  private dataArray: Float32Array | null = null;\r\n\r\n  public async startMonitoring(): Promise<void> {\r\n    try {\r\n      if (!this.audioContext) {\r\n        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      }\r\n\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        audio: {\r\n          echoCancellation: true,\r\n          noiseSuppression: true,\r\n          autoGainControl: true\r\n        }\r\n      });\r\n      \r\n      this.mediaStream = stream;\r\n\r\n      this.sourceNode = this.audioContext.createMediaStreamSource(stream);\r\n      this.analyserNode = this.audioContext.createAnalyser();\r\n      \r\n      this.analyserNode.fftSize = 2048;\r\n      this.analyserNode.smoothingTimeConstant = 0.8;\r\n      this.analyserNode.minDecibels = -90;\r\n      this.analyserNode.maxDecibels = -10;\r\n      \r\n      this.sourceNode.connect(this.analyserNode);\r\n      \r\n      this.dataArray = new Float32Array(this.analyserNode.frequencyBinCount);\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      throw new Error('Failed to start audio monitoring: ' + errorMessage);\r\n    }\r\n  }\r\n\r\n  public getVolume(): number {\r\n    if (!this.analyserNode || !this.dataArray) {\r\n      return 0;\r\n    }\r\n\r\n    this.analyserNode.getFloatTimeDomainData(this.dataArray);\r\n\r\n    let sum = 0;\r\n    for (let i = 0; i < this.dataArray.length; i++) {\r\n      sum += this.dataArray[i] * this.dataArray[i];\r\n    }\r\n    const rms = Math.sqrt(sum / this.dataArray.length);\r\n\r\n    return Math.min(100, Math.max(0, rms * 100));\r\n  }\r\n\r\n  public stopMonitoring(): void {\r\n    if (this.mediaStream) {\r\n      this.mediaStream.getTracks().forEach(track => track.stop());\r\n    }\r\n\r\n    if (this.sourceNode) {\r\n      this.sourceNode.disconnect();\r\n    }\r\n\r\n    if (this.audioContext && this.audioContext.state !== 'closed') {\r\n      this.audioContext.close();\r\n    }\r\n\r\n    this.audioContext = null;\r\n    this.analyserNode = null;\r\n    this.sourceNode = null;\r\n    this.mediaStream = null;\r\n    this.dataArray = null;\r\n  }\r\n\r\n  public resume(): void {\r\n    if (this.audioContext?.state === 'suspended') {\r\n      this.audioContext.resume();\r\n    }\r\n  }\r\n\r\n  public suspend(): void {\r\n    if (this.audioContext?.state === 'running') {\r\n      this.audioContext.suspend();\r\n    }\r\n  }\r\n}\r\n\r\nexport const audioContextManager = new AudioContextManager(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}